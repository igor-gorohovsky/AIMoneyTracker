# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: queries.sql
import decimal
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from db import models


CREATE_ACCOUNT = """-- name: create_account \\:one
INSERT INTO account(
    user_id, name, balance, currency_id
) VALUES (
    :p1, :p2, :p3, :p4
)
RETURNING account_id, user_id, name, balance, currency_id
"""


CREATE_CATEGORY = """-- name: create_category \\:one
INSERT INTO category(
    user_id, name, type
) VALUES (
    :p1, :p2, :p3
)
RETURNING category_id, user_id, name, type
"""


CREATE_CURRENCY = """-- name: create_currency \\:one
INSERT INTO currency(
    name, iso_code, symbol
) VALUES (
    :p1, :p2, :p3
)
RETURNING currency_id, name, iso_code, symbol
"""


CREATE_RATE = """-- name: create_rate \\:one
INSERT INTO rate(
    from_currency, to_currency, rate
) VALUES (
    :p1, :p2, :p3
)
RETURNING rate_id, from_currency, to_currency, rate, updated_at
"""


CREATE_USER = """-- name: create_user \\:one
INSERT INTO user_account(
    user_tg_id, currency_id
) VALUES (
    :p1, :p2
)
RETURNING user_id, user_tg_id, balance, currency_id
"""


GET_ACCOUNTS = """-- name: get_accounts \\:many
SELECT account_id, user_id, name, balance, currency_id FROM account
WHERE user_id = :p1
"""


GET_CATEGORY_BY_ID = """-- name: get_category_by_id \\:one
SELECT category_id, user_id, name, type FROM category
WHERE category_id = :p1 AND user_id = :p2
"""


GET_CATEGORY_BY_NAME = """-- name: get_category_by_name \\:one
SELECT category_id, user_id, name, type FROM category
WHERE name = :p1 AND user_id = :p2
"""


GET_CURRENCY = """-- name: get_currency \\:one
SELECT currency_id, name, iso_code, symbol FROM currency
WHERE iso_code = :p1
"""


GET_RATE = """-- name: get_rate \\:one
SELECT rate_id, from_currency, to_currency, rate, updated_at FROM rate
WHERE from_currency = :p1 AND to_currency = :p2
"""


GET_USER = """-- name: get_user \\:one
SELECT user_id, user_tg_id, balance, currency_id FROM user_account
WHERE user_tg_id = :p1
"""


GET_USER_CATEGORIES = """-- name: get_user_categories \\:many
SELECT category_id, user_id, name, type FROM category
WHERE user_id = :p1
"""


UPDATE_CATEGORY = """-- name: update_category \\:one
UPDATE category
SET name = :p2
WHERE category_id = :p1
RETURNING category_id, user_id, name, type
"""


UPDATE_RATE = """-- name: update_rate \\:one
UPDATE rate
SET rate = :p3
WHERE from_currency = :p1 AND to_currency = :p2
RETURNING rate_id, from_currency, to_currency, rate, updated_at
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_account(self, *, user_id: int, name: str, balance: decimal.Decimal, currency_id: int) -> Optional[models.Account]:
        row = self._conn.execute(sqlalchemy.text(CREATE_ACCOUNT), {
            "p1": user_id,
            "p2": name,
            "p3": balance,
            "p4": currency_id,
        }).first()
        if row is None:
            return None
        return models.Account(
            account_id=row[0],
            user_id=row[1],
            name=row[2],
            balance=row[3],
            currency_id=row[4],
        )

    def create_category(self, *, user_id: int, name: str, type: str) -> Optional[models.Category]:
        row = self._conn.execute(sqlalchemy.text(CREATE_CATEGORY), {"p1": user_id, "p2": name, "p3": type}).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    def create_currency(self, *, name: str, iso_code: str, symbol: str) -> Optional[models.Currency]:
        row = self._conn.execute(sqlalchemy.text(CREATE_CURRENCY), {"p1": name, "p2": iso_code, "p3": symbol}).first()
        if row is None:
            return None
        return models.Currency(
            currency_id=row[0],
            name=row[1],
            iso_code=row[2],
            symbol=row[3],
        )

    def create_rate(self, *, from_currency: int, to_currency: int, rate: decimal.Decimal) -> Optional[models.Rate]:
        row = self._conn.execute(sqlalchemy.text(CREATE_RATE), {"p1": from_currency, "p2": to_currency, "p3": rate}).first()
        if row is None:
            return None
        return models.Rate(
            rate_id=row[0],
            from_currency=row[1],
            to_currency=row[2],
            rate=row[3],
            updated_at=row[4],
        )

    def create_user(self, *, user_tg_id: int, currency_id: int) -> Optional[models.UserAccount]:
        row = self._conn.execute(sqlalchemy.text(CREATE_USER), {"p1": user_tg_id, "p2": currency_id}).first()
        if row is None:
            return None
        return models.UserAccount(
            user_id=row[0],
            user_tg_id=row[1],
            balance=row[2],
            currency_id=row[3],
        )

    def get_accounts(self, *, user_id: int) -> Iterator[models.Account]:
        result = self._conn.execute(sqlalchemy.text(GET_ACCOUNTS), {"p1": user_id})
        for row in result:
            yield models.Account(
                account_id=row[0],
                user_id=row[1],
                name=row[2],
                balance=row[3],
                currency_id=row[4],
            )

    def get_category_by_id(self, *, category_id: int, user_id: int) -> Optional[models.Category]:
        row = self._conn.execute(sqlalchemy.text(GET_CATEGORY_BY_ID), {"p1": category_id, "p2": user_id}).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    def get_category_by_name(self, *, name: str, user_id: int) -> Optional[models.Category]:
        row = self._conn.execute(sqlalchemy.text(GET_CATEGORY_BY_NAME), {"p1": name, "p2": user_id}).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    def get_currency(self, *, iso_code: str) -> Optional[models.Currency]:
        row = self._conn.execute(sqlalchemy.text(GET_CURRENCY), {"p1": iso_code}).first()
        if row is None:
            return None
        return models.Currency(
            currency_id=row[0],
            name=row[1],
            iso_code=row[2],
            symbol=row[3],
        )

    def get_rate(self, *, from_currency: int, to_currency: int) -> Optional[models.Rate]:
        row = self._conn.execute(sqlalchemy.text(GET_RATE), {"p1": from_currency, "p2": to_currency}).first()
        if row is None:
            return None
        return models.Rate(
            rate_id=row[0],
            from_currency=row[1],
            to_currency=row[2],
            rate=row[3],
            updated_at=row[4],
        )

    def get_user(self, *, user_tg_id: int) -> Optional[models.UserAccount]:
        row = self._conn.execute(sqlalchemy.text(GET_USER), {"p1": user_tg_id}).first()
        if row is None:
            return None
        return models.UserAccount(
            user_id=row[0],
            user_tg_id=row[1],
            balance=row[2],
            currency_id=row[3],
        )

    def get_user_categories(self, *, user_id: int) -> Iterator[models.Category]:
        result = self._conn.execute(sqlalchemy.text(GET_USER_CATEGORIES), {"p1": user_id})
        for row in result:
            yield models.Category(
                category_id=row[0],
                user_id=row[1],
                name=row[2],
                type=row[3],
            )

    def update_category(self, *, category_id: int, name: str) -> Optional[models.Category]:
        row = self._conn.execute(sqlalchemy.text(UPDATE_CATEGORY), {"p1": category_id, "p2": name}).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    def update_rate(self, *, from_currency: int, to_currency: int, rate: decimal.Decimal) -> Optional[models.Rate]:
        row = self._conn.execute(sqlalchemy.text(UPDATE_RATE), {"p1": from_currency, "p2": to_currency, "p3": rate}).first()
        if row is None:
            return None
        return models.Rate(
            rate_id=row[0],
            from_currency=row[1],
            to_currency=row[2],
            rate=row[3],
            updated_at=row[4],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_account(self, *, user_id: int, name: str, balance: decimal.Decimal, currency_id: int) -> Optional[models.Account]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_ACCOUNT), {
            "p1": user_id,
            "p2": name,
            "p3": balance,
            "p4": currency_id,
        })).first()
        if row is None:
            return None
        return models.Account(
            account_id=row[0],
            user_id=row[1],
            name=row[2],
            balance=row[3],
            currency_id=row[4],
        )

    async def create_category(self, *, user_id: int, name: str, type: str) -> Optional[models.Category]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_CATEGORY), {"p1": user_id, "p2": name, "p3": type})).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    async def create_currency(self, *, name: str, iso_code: str, symbol: str) -> Optional[models.Currency]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_CURRENCY), {"p1": name, "p2": iso_code, "p3": symbol})).first()
        if row is None:
            return None
        return models.Currency(
            currency_id=row[0],
            name=row[1],
            iso_code=row[2],
            symbol=row[3],
        )

    async def create_rate(self, *, from_currency: int, to_currency: int, rate: decimal.Decimal) -> Optional[models.Rate]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_RATE), {"p1": from_currency, "p2": to_currency, "p3": rate})).first()
        if row is None:
            return None
        return models.Rate(
            rate_id=row[0],
            from_currency=row[1],
            to_currency=row[2],
            rate=row[3],
            updated_at=row[4],
        )

    async def create_user(self, *, user_tg_id: int, currency_id: int) -> Optional[models.UserAccount]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_USER), {"p1": user_tg_id, "p2": currency_id})).first()
        if row is None:
            return None
        return models.UserAccount(
            user_id=row[0],
            user_tg_id=row[1],
            balance=row[2],
            currency_id=row[3],
        )

    async def get_accounts(self, *, user_id: int) -> AsyncIterator[models.Account]:
        result = await self._conn.stream(sqlalchemy.text(GET_ACCOUNTS), {"p1": user_id})
        async for row in result:
            yield models.Account(
                account_id=row[0],
                user_id=row[1],
                name=row[2],
                balance=row[3],
                currency_id=row[4],
            )

    async def get_category_by_id(self, *, category_id: int, user_id: int) -> Optional[models.Category]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CATEGORY_BY_ID), {"p1": category_id, "p2": user_id})).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    async def get_category_by_name(self, *, name: str, user_id: int) -> Optional[models.Category]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CATEGORY_BY_NAME), {"p1": name, "p2": user_id})).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    async def get_currency(self, *, iso_code: str) -> Optional[models.Currency]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CURRENCY), {"p1": iso_code})).first()
        if row is None:
            return None
        return models.Currency(
            currency_id=row[0],
            name=row[1],
            iso_code=row[2],
            symbol=row[3],
        )

    async def get_rate(self, *, from_currency: int, to_currency: int) -> Optional[models.Rate]:
        row = (await self._conn.execute(sqlalchemy.text(GET_RATE), {"p1": from_currency, "p2": to_currency})).first()
        if row is None:
            return None
        return models.Rate(
            rate_id=row[0],
            from_currency=row[1],
            to_currency=row[2],
            rate=row[3],
            updated_at=row[4],
        )

    async def get_user(self, *, user_tg_id: int) -> Optional[models.UserAccount]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER), {"p1": user_tg_id})).first()
        if row is None:
            return None
        return models.UserAccount(
            user_id=row[0],
            user_tg_id=row[1],
            balance=row[2],
            currency_id=row[3],
        )

    async def get_user_categories(self, *, user_id: int) -> AsyncIterator[models.Category]:
        result = await self._conn.stream(sqlalchemy.text(GET_USER_CATEGORIES), {"p1": user_id})
        async for row in result:
            yield models.Category(
                category_id=row[0],
                user_id=row[1],
                name=row[2],
                type=row[3],
            )

    async def update_category(self, *, category_id: int, name: str) -> Optional[models.Category]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_CATEGORY), {"p1": category_id, "p2": name})).first()
        if row is None:
            return None
        return models.Category(
            category_id=row[0],
            user_id=row[1],
            name=row[2],
            type=row[3],
        )

    async def update_rate(self, *, from_currency: int, to_currency: int, rate: decimal.Decimal) -> Optional[models.Rate]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_RATE), {"p1": from_currency, "p2": to_currency, "p3": rate})).first()
        if row is None:
            return None
        return models.Rate(
            rate_id=row[0],
            from_currency=row[1],
            to_currency=row[2],
            rate=row[3],
            updated_at=row[4],
        )
